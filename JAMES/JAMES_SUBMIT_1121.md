

# lotto

```python
# 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다.
# 첫 번째 수는 k (6 < k < 13)이고, 다음 k개 수는 집합 S에 포함되는 수이다. S의 원소는 오름차순으로 주어진다.
# 입력의 마지막 줄에는 0이 하나 주어진다.

"""
7 1 2 3 4 5 6 7
8 1 2 3 5 8 13 21 34
0

1 2 3 4 5 6
1 2 3 4 5 7
1 2 3 4 6 7
1 2 3 5 6 7
1 2 4 5 6 7
1 3 4 5 6 7
2 3 4 5 6 7

1 2 3 5 8 13
1 2 3 5 8 21
1 2 3 5 8 34
1 2 3 5 13 21
1 2 3 5 13 34
1 2 3 5 21 34
1 2 3 8 13 21
1 2 3 8 13 34
1 2 3 8 21 34
1 2 3 13 21 34
1 2 5 8 13 21
1 2 5 8 13 34
1 2 5 8 21 34
1 2 5 13 21 34
1 2 8 13 21 34
1 3 5 8 13 21
1 3 5 8 13 34
1 3 5 8 21 34
1 3 5 13 21 34
1 3 8 13 21 34
1 5 8 13 21 34
2 3 5 8 13 21
2 3 5 8 13 34
2 3 5 8 21 34
2 3 5 13 21 34
2 3 8 13 21 34
2 5 8 13 21 34
3 5 8 13 21 34
"""

# 조합문제를 재귀로

import sys

def comb(idx, start):
    if idx == 6:
        print(*sel)
    else:
        for i in range(start, N):
            if visit[i] == 0:
                sel[idx] = numbers[i]
                visit[i] = 1
                comb(idx + 1, i + 1)
                visit[i] = 0

while True:
    numbers = list(map(int, sys.stdin.readline().split()))
    if numbers == [0]:
        break
    N = numbers[0]
    numbers = numbers[1:]
    sel = [0] * 6
    visit = [0] * N
    tmp = []
    comb(0, 0)
    print('')
```



# ATM

```python
# 줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램
# 오름차순 정렬해서 값을 저장하면서 더하기

"""
5
3 1 4 3 2

32
"""
n = int(input()) # 사람 수
arr = list(map(int,input().split())) # 인출 시간
arr.sort() # 정렬

result = 0

for i in range(1,n):
    arr[i] += arr[i-1] # 인출 시간 갱신

print(sum(arr))
```

# 에너지모으기.. 잘몰르겟둥

```python
# 에너지 구슬 하나를 고른다. 고른 에너지 구슬의 번호를 x라고 한다. 단, 첫 번째와 마지막 에너지 구슬은 고를 수 없다.
# x번째 에너지 구슬을 제거한다.
# Wx-1 × Wx+1의 에너지를 모을 수 있다.
# N을 1 감소시키고, 에너지 구슬을 1번부터 N번까지로 다시 번호를 매긴다. 번호는 첫 구슬이 1번, 다음 구슬이 2번, ... 과 같이 매겨야 한다.
# N과 에너지 구슬의 무게가 주어졌을 때, 모을 수 있는 에너지 양의 최댓값을 구하는 프로그램을 작성하시오.

"""
4
1 2 3 4

12

5
100 2 1 3 100

10400

7
2 2 7 6 90 5 9

1818

10
1 1 1 1 1 1 1 1 1 1

8
"""

# 아직 이해안댐...
```



# 주유소

```python
# 제일 왼쪽 도시에서 6리터의 기름을 넣고, 더 이상의 주유 없이 제일 오른쪽 도시까지 이동하면 총 비용은 30원이다.
# 만약 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 3리터의 기름을 넣고(3×2 = 6원)
# 다음 도시에서 1리터의 기름을 넣어(1×4 = 4원) 제일 오른쪽 도시로 이동하면, 총 비용은 20원이다.
# 또 다른 방법으로 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 4리터의 기름을 넣고(4×2 = 8원) 제일 오른쪽 도시까지 이동하면, 총 비용은 18원이다.
# 각 도시에 있는 주유소의 기름 가격과, 각 도시를 연결하는 도로의 길이를 입력으로 받아 제일 왼쪽 도시에서 제일 오른쪽 도시로 이동하는 최소의 비용을 계산하는 프로그램을 작성하시오.

"""
4
2 3 1
5 2 4 1

18

4
3 3 4
1 1 1 1

10

"""

city_number = int(input())
line_length = list(map(int, input().split()))
oil_price = list(map(int, input().split()))
min_price = oil_price[0]
total = 0
for i in range(len(line_length)):
    if oil_price[i] >= min_price:
        total += min_price * line_length[i]
    elif oil_price[i] < min_price:
        min_price = oil_price[i]
        total += min_price * line_length[i]
print(total)
```



# 회의실 배정

```python
# 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다.
# 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자.
# 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.
# 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

"""
11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14

4
"""

import sys
N = int(sys.stdin.readline())
time = [[0]*2 for _ in range(N)]
for i in range(N):
    s, e = map(int, sys.stdin.readline().split())
    time[i][0] = s
    time[i][1] = e

time.sort(key = lambda x: (x[1], x[0]))
cnt = 1
end_time = time[0][1]

for i in range(1, N):
    if time[i][0] >= end_time:
        cnt += 1
        end_time = time[i][1]

print(cnt)
```



# 병든 나이트 -....sry

```python
"""
100 50

48

1 1

1

17 5

4

2 4

2

20 4

4
"""


```



# 뚜에모스문자열

```python
# 1의 개수가 홀수개와 짝수개에 따라 값이 바뀐다...
"""
0
1
10
11
100
101
110
111
1000
1001
1010
1011
1100
1101
1110
1111
"""
# 0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0
if bin(int(input())-1).count('1') % 2 == 0:
    print(0)
else:
    print(1)
```





